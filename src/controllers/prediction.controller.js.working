
const axios = require('axios');
const Prediction = require('../models/prediction.model');
const stateDistrictSoil = require('../data/state_district_soil.json');
const soilProperties = require('../data/soil_properties.json');

// External API functions for fetching weather and soil data
const getWeatherData = async (state, district, date) => {
  try {
    if (!process.env.WEATHER_API_KEY) {
      throw new Error('Weather API key not configured');
    }
    
    const location = `${district}, ${state}`;
    console.log(`ðŸŒ¤ï¸ Fetching weather data for ${location} on ${date}`);
    
    // OpenWeatherMap API call
    const response = await axios.get(`https://api.openweathermap.org/data/2.5/weather`, {
      params: {
        q: location,
        appid: process.env.WEATHER_API_KEY,
        units: 'metric'
      }
    });
    
    const data = response.data;
    return {
      temperature: data.main.temp,
      rainfall: data.rain ? (data.rain['1h'] || data.rain['3h'] || 0) : 0,
      humidity: data.main.humidity,
      coordinates: {
        latitude: data.coord.lat,
        longitude: data.coord.lon
      },
      raw: data
    };
  } catch (error) {
    console.error('Weather API error:', error.message);
    // Return mock data as fallback
    return {
      temperature: 25,
      rainfall: 50,
      humidity: 70,
      coordinates: { latitude: 0, longitude: 0 },
      raw: { error: error.message }
    };
  }
};

const getSoilData = async (state, district, coordinates = null) => {
  try {
    console.log(`ðŸŒ± Fetching soil data for ${district}, ${state}`);
    
    // Normalize state and district names for lookup
    const normalizedState = state.trim();
    const normalizedDistrict = district.trim();
    
    // Find soil type from local JSON data
    let soilType = null;
    let foundInData = false;
    
    // First, try exact match
    if (stateDistrictSoil[normalizedState] && stateDistrictSoil[normalizedState][normalizedDistrict]) {
      soilType = stateDistrictSoil[normalizedState][normalizedDistrict][0];
      foundInData = true;
      console.log(`âœ… Exact match found: ${normalizedDistrict}, ${normalizedState} -> ${soilType}`);
    }
    
    // If not found, try case-insensitive search
    if (!foundInData) {
      const stateKeys = Object.keys(stateDistrictSoil);
      for (const stateKey of stateKeys) {
        if (stateKey.toLowerCase() === normalizedState.toLowerCase()) {
          const districts = stateDistrictSoil[stateKey];
          const districtKeys = Object.keys(districts);
          
          for (const districtKey of districtKeys) {
            if (districtKey.toLowerCase() === normalizedDistrict.toLowerCase() ||
                districtKey.toLowerCase().includes(normalizedDistrict.toLowerCase()) ||
                normalizedDistrict.toLowerCase().includes(districtKey.toLowerCase())) {
              soilType = districts[districtKey][0];
              foundInData = true;
              console.log(`âœ… Fuzzy match found: ${districtKey} -> ${soilType}`);
              break;
            }
          }
          if (foundInData) break;
        }
      }
    }
    
    // If still not found, use state-level default
    if (!foundInData) {
      console.log(`âš ï¸ District ${normalizedDistrict} not found in ${normalizedState}`);
      
      // Get default soil type for the state (most common in that state)
      const stateDefaults = {
        'Gujarat': 'Sandy',
        'Maharashtra': 'Loamy', 
        'Madhya Pradesh': 'Black',
        'Uttar Pradesh': 'Alluvial',
        'West Bengal': 'Alluvial',
        'Bihar': 'Alluvial',
        'Jharkhand': 'Red',
        'Orissa': 'Red',
        'Chhattisgarh': 'Red-Yellow',
        'Karnataka': 'Loamy',
        'Tamil Nadu': 'Loamy',
        'Andhra Pradesh': 'Loamy',
        'Telangana': 'Loamy',
        'Kerala': 'Loamy',
        'Punjab': 'Loamy',
        'Haryana': 'Loamy',
        'Rajasthan': 'Loamy',
        'Himachal Pradesh': 'Loamy',
        'Uttarakhand': 'Loamy',
        'Assam': 'Loamy'
      };
      
      soilType = stateDefaults[normalizedState] || 'Loamy';
      console.log(`ðŸ“ Using state default for ${normalizedState}: ${soilType}`);
    }
    
    // Get detailed soil properties from soil_properties.json
    const soilData = soilProperties.soilProperties[soilType] || soilProperties.soilProperties['Loamy'];
    
    // Create comprehensive soil data response
    const comprehensiveSoilData = {
      soilType: soilType, // ML-compatible type
      detailedSoilType: soilType, // Same as soil type for JSON data
      composition: soilData.composition,
      properties: soilData.properties,
      analysis: soilData.analysis,
      recommendations: soilData.recommendations,
      suitableCrops: soilData.crops.suitable,
      coordinates: coordinates || { latitude: null, longitude: null },
      dataSource: foundInData ? 'local_database' : 'state_default',
      location: `${normalizedDistrict}, ${normalizedState}`,
      raw: {
        searchedState: normalizedState,
        searchedDistrict: normalizedDistrict,
        foundInDatabase: foundInData,
        soilTypeSource: foundInData ? 'district_specific' : 'state_default'
      }
    };
    
    console.log(`ðŸŒ± Soil Analysis Complete:`);
    console.log(`   Type: ${soilType}`);
    console.log(`   Composition: Sand ${soilData.composition.sand}%, Clay ${soilData.composition.clay}%, Silt ${soilData.composition.silt}%`);
    console.log(`   pH: ${soilData.properties.pH}, Fertility: ${soilData.properties.fertility}`);
    console.log(`   Data Source: ${comprehensiveSoilData.dataSource}`);
    
    return comprehensiveSoilData;
    
  } catch (error) {
    console.error('Local soil data lookup error:', error.message);
    
    // Enhanced fallback with basic soil analysis
    const fallbackSoilType = 'Loamy';
    const fallbackData = soilProperties.soilProperties[fallbackSoilType];
    
    return {
      soilType: fallbackSoilType,
      detailedSoilType: fallbackSoilType,
      composition: fallbackData.composition,
      properties: fallbackData.properties,
      analysis: fallbackData.analysis,
      recommendations: ['Unable to fetch soil data from local database', ...fallbackData.recommendations],
      suitableCrops: fallbackData.crops.suitable,
      coordinates: coordinates || { latitude: null, longitude: null },
      dataSource: 'fallback',
      location: `${district}, ${state}`,
      raw: { error: error.message }
    };
  }
};

// @desc    Create a new prediction
// @route   POST /api/predict
// @access  Private
const createPrediction = async (req, res) => {
  const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const startTime = Date.now();
  
  console.log(`\nðŸŽ¯ [${requestId}] NEW PREDICTION REQUEST STARTED`);
  console.log(`â° Timestamp: ${new Date().toISOString()}`);
  console.log(`ðŸ“ IP: ${req.ip || req.connection.remoteAddress}`);
  console.log(`ðŸ‘¤ User-Agent: ${req.headers['user-agent']?.substring(0, 50)}...`);
  
  const { 
    cropType, 
    landArea, 
    location, 
    plantingDate, 
    fetchData = false,
    // Optional user-provided data
    soilType,
    weather 
  } = req.body;
  
  console.log(`ðŸ“¦ [${requestId}] REQUEST PAYLOAD:`);
  console.log(`   ðŸŒ¾ Crop Type: ${cropType}`);
  console.log(`   ðŸ“ Land Area: ${landArea} hectares`);
  console.log(`   ðŸ“ Location: ${location?.district}, ${location?.state}`);
  console.log(`   ðŸ“… Planting Date: ${plantingDate}`);
  console.log(`   ðŸ”„ Fetch External Data: ${fetchData}`);
  console.log(`   ðŸŒ± User Soil Type: ${soilType || 'Not provided'}`);
  console.log(`   ï¿½ï¸ User Weather: ${weather ? 'Provided' : 'Not provided'}`);
  
  const userId = req.user._id;
  console.log(`ðŸ‘¤ [${requestId}] User ID: ${userId}`);

  try {
    console.log(`\nðŸŒ¾ [${requestId}] STARTING PREDICTION PROCESS`);
    console.log(`ðŸ“Š Crop: ${cropType}, Area: ${landArea}ha, Location: ${location.district}, ${location.state}`);
    console.log(`ðŸ”„ Fetch external data: ${fetchData}`);

    let finalWeatherData = null;
    let finalSoilData = null;
    let coordinates = location.coordinates || { latitude: 0, longitude: 0 };

    if (fetchData) {
      console.log(`\nðŸ“¡ [${requestId}] FETCHING EXTERNAL DATA...`);
      console.log(`ðŸŒ¤ï¸ Fetching weather data for ${location.state}, ${location.district}`);
      
      // Fetch weather data
      const weatherStartTime = Date.now();
      const weatherApiData = await getWeatherData(location.state, location.district, plantingDate);
      const weatherDuration = Date.now() - weatherStartTime;
      console.log(`â±ï¸ [${requestId}] Weather API took: ${weatherDuration}ms`);
      
      coordinates = weatherApiData.coordinates;
      
      finalWeatherData = {
        temperature: weatherApiData.temperature,
        rainfall: weatherApiData.rainfall,
        humidity: weatherApiData.humidity,
        dataSource: 'api'
      };
      
      console.log(`âœ… [${requestId}] Weather data retrieved:`);
      console.log(`   ðŸŒ¡ï¸ Temperature: ${finalWeatherData.temperature}Â°C`);
      console.log(`   ðŸŒ§ï¸ Rainfall: ${finalWeatherData.rainfall}mm`);
      console.log(`   ðŸ’§ Humidity: ${finalWeatherData.humidity}%`);
      console.log(`   ðŸ“ Coordinates: ${coordinates.latitude}, ${coordinates.longitude}`);
      
      // Fetch soil data using state and district from location
      console.log(`\nðŸŒ± [${requestId}] FETCHING SOIL DATA...`);
      const soilStartTime = Date.now();
      const soilApiData = await getSoilData(location.state, location.district, coordinates);
      const soilDuration = Date.now() - soilStartTime;
      console.log(`â±ï¸ [${requestId}] Soil data lookup took: ${soilDuration}ms`);
      
      finalSoilData = {
        type: soilApiData.soilType, // ML-compatible type
        detailedType: soilApiData.detailedSoilType,
        composition: soilApiData.composition,
        properties: soilApiData.properties,
        analysis: soilApiData.analysis,
        recommendations: soilApiData.recommendations,
        suitableCrops: soilApiData.suitableCrops,
        dataSource: 'local_database'
      };
      
      console.log(`âœ… [${requestId}] Soil data retrieved:`);
      console.log(`   ðŸŒ± Soil Type: ${finalSoilData.detailedType} (ML: ${finalSoilData.type})`);
      console.log(`   ðŸ§ª pH: ${finalSoilData.properties.pH}, Fertility: ${finalSoilData.properties.fertility}`);
      console.log(`   ðŸ“Š Composition: Sand ${finalSoilData.composition.sand}%, Clay ${finalSoilData.composition.clay}%, Silt ${finalSoilData.composition.silt}%`);
      console.log(`   ðŸŒ¾ Suitable Crops: ${finalSoilData.suitableCrops.join(', ')}`);
      console.log(`   ðŸ“‹ Data Source: ${finalSoilData.dataSource}`);
      
    } else {
      console.log(`\nðŸ‘¤ [${requestId}] USING USER-PROVIDED DATA`);
      
      // Use user-provided data
      finalWeatherData = weather ? {
        temperature: weather.temperature,
        rainfall: weather.rainfall,
        humidity: weather.humidity,
        dataSource: 'user'
      } : null;
      
      finalSoilData = soilType ? {
        type: soilType,
        detailedType: soilType,
        composition: null,
        properties: null,
        analysis: null,
        recommendations: [],
        dataSource: 'user'
      } : {
        type: 'Unknown',
        detailedType: 'Unknown',
        composition: null,
        properties: null,
        analysis: null,
        recommendations: [],
        dataSource: 'default'
      };
      
      console.log(`ðŸ‘¤ [${requestId}] User data processed:`);
      console.log(`   ðŸŒ¤ï¸ Weather: ${finalWeatherData ? 'Provided' : 'Not provided'}`);
      console.log(`   ðŸŒ± Soil: ${finalSoilData.type}`);
    }

    // Validate and normalize inputs for ML API according to specification
    console.log(`\nðŸ”„ [${requestId}] VALIDATING AND NORMALIZING INPUT DATA...`);
    
    const validStates = ['Chhattisgarh', 'Madhya Pradesh', 'West Bengal', 'Bihar', 'Jharkhand', 'Orissa', 'Gujarat'];
    const validCrops = ['RICE', 'GROUNDNUT', 'WHEAT', 'MAIZE', 'SUGARCANE'];
    const validSoilTypes = ['Sandy', 'Alluvial', 'Black', 'Red-Yellow', 'Red', 'Loamy'];
    
    console.log(`ðŸ” [${requestId}] Validation criteria:`);
    console.log(`   ðŸ›ï¸ Valid States: ${validStates.join(', ')}`);
    console.log(`   ðŸŒ¾ Valid Crops: ${validCrops.join(', ')}`);
    console.log(`   ðŸŒ± Valid Soil Types: ${validSoilTypes.join(', ')}`);
    
    // Normalize crop type to ML API format
    const cropMapping = {
      'Rice': 'RICE',
      'Groundnut': 'GROUNDNUT', 
      'Wheat': 'WHEAT',
      'Maize': 'MAIZE',
      'Corn': 'MAIZE',
      'Sugarcane': 'SUGARCANE'
    };
    
    const normalizedCrop = cropMapping[cropType] || cropType.toUpperCase();
    const normalizedState = location.state;
    const normalizedSoilType = typeof finalSoilData === 'object' ? finalSoilData.type : finalSoilData;
    
    console.log(`ðŸ”„ [${requestId}] Normalization results:`);
    console.log(`   ðŸŒ¾ Input Crop: "${cropType}" â†’ Normalized: "${normalizedCrop}"`);
    console.log(`   ðŸ›ï¸ Input State: "${normalizedState}"`);
    console.log(`   ðŸŒ± Input Soil: "${normalizedSoilType}"`);
    
    // Validate inputs
    if (!validStates.includes(normalizedState)) {
      console.warn(`âš ï¸ [${requestId}] State '${normalizedState}' not in ML model's supported states. Using 'Gujarat' as fallback.`);
    }
    
    if (!validCrops.includes(normalizedCrop)) {
      console.warn(`âš ï¸ [${requestId}] Crop '${normalizedCrop}' not supported by ML model. Using 'RICE' as fallback.`);
    }
    
    if (!validSoilTypes.includes(normalizedSoilType)) {
      console.warn(`âš ï¸ [${requestId}] Soil type '${normalizedSoilType}' not supported by ML model. Using 'Loamy' as fallback.`);
    }

    // Prepare data for ML model API in the exact format specified by your backend
    const mlInput = {
      Year: new Date(plantingDate).getFullYear().toString(),
      State: validStates.includes(normalizedState) ? normalizedState : 'Gujarat',
      District: location.district.toLowerCase(), // Convert to lowercase as per your example
      Area_1000_ha: (landArea / 1000).toFixed(3).toString(), // Convert to string
      Crop: validCrops.includes(normalizedCrop) ? normalizedCrop : 'RICE',
      Avg_Rainfall_mm: Math.round(finalWeatherData?.rainfall || 50).toString(), // Convert to string, rounded
      Avg_Temp_C: Math.round(finalWeatherData?.temperature || 25).toString(), // Convert to string, rounded
      Soil_Type: validSoilTypes.includes(normalizedSoilType) ? normalizedSoilType : 'Sandy'
    };

    console.log(`\nðŸ¤– [${requestId}] ML MODEL INPUT PREPARATION COMPLETE`);
    console.log(`ðŸ“¤ ML Input data (exact backend format):`);
    console.log(`   ðŸ“… Year: ${mlInput.Year}`);
    console.log(`   ðŸ›ï¸ State: ${mlInput.State}`);
    console.log(`   ðŸ˜ï¸ District: ${mlInput.District}`);
    console.log(`   ðŸ“ Area_1000_ha: ${mlInput.Area_1000_ha}`);
    console.log(`   ðŸŒ¾ Crop: ${mlInput.Crop}`);
    console.log(`   ðŸŒ§ï¸ Avg_Rainfall_mm: ${mlInput.Avg_Rainfall_mm}`);
    console.log(`   ðŸŒ¡ï¸ Avg_Temp_C: ${mlInput.Avg_Temp_C}`);
    console.log(`   ðŸŒ± Soil_Type: ${mlInput.Soil_Type}`);
    console.log(`ðŸ“‹ Full ML Input JSON:`);
    console.log(JSON.stringify(mlInput, null, 2));

    let mlResponse = null;
    let predictedYield = 0;
    let confidence = 0;
    let mlModelUsed = false;
    let errorDetails = null;

    // Call ML Model API
    console.log(`\nðŸš€ [${requestId}] CALLING ML MODEL API...`);
    console.log(`ï¿½ ML API URL: ${process.env.ML_MODEL_API_URL || 'Not configured'}`);
    
    const mlStartTime = Date.now();
    
    try {
      if (!process.env.ML_MODEL_API_URL) {
        throw new Error('ML_MODEL_API_URL not configured in environment variables');
      }
      
      console.log(`ðŸ“¡ [${requestId}] Sending request to ML API...`);
      console.log(`ðŸ“¤ Request headers: Content-Type: application/json`);
      console.log(`â±ï¸ Request timeout: 15000ms`);
      
      mlResponse = await axios.post(process.env.ML_MODEL_API_URL, mlInput, {
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        timeout: 15000 // 15 second timeout
      });
      
      const mlDuration = Date.now() - mlStartTime;
      console.log(`â±ï¸ [${requestId}] ML API call took: ${mlDuration}ms`);
      console.log(`âœ… [${requestId}] ML API Response received`);
      console.log(`ðŸ“¥ ML Response status: ${mlResponse.status}`);
      console.log(`ðŸ“Š ML Response headers:`, JSON.stringify(mlResponse.headers, null, 2));
      console.log(`ðŸ“¥ ML Response data:`, JSON.stringify(mlResponse.data, null, 2));
      
      // Extract prediction data from ML response
      const mlData = mlResponse.data;
      
      // Handle the ML API response format
      if (mlData.yield_kg_ha !== null && mlData.yield_kg_ha !== undefined) {
        // Convert kg/ha to total tons for the land area
        const yieldKgPerHa = mlData.yield_kg_ha;
        predictedYield = parseFloat(((yieldKgPerHa * landArea) / 1000).toFixed(2)); // Convert kg to tons
        
        console.log(`ðŸ“Š [${requestId}] ML Prediction Calculation:`);
        console.log(`   ðŸŒ¾ Yield per hectare: ${yieldKgPerHa} kg/ha`);
        console.log(`   ðŸ“ Land area: ${landArea} hectares`);
        console.log(`   ðŸ§® Calculation: (${yieldKgPerHa} Ã— ${landArea}) Ã· 1000 = ${predictedYield} tons`);
        
        // Calculate confidence from confidence interval if available
        if (mlData.confidence_interval_95 && Array.isArray(mlData.confidence_interval_95)) {
          const [lower, upper] = mlData.confidence_interval_95;
          const range = upper - lower;
          const mean = (upper + lower) / 2;
          confidence = Math.max(0.5, Math.min(0.95, 1 - (range / mean / 2))); // Estimate confidence
          
          console.log(`ðŸ“ˆ [${requestId}] Confidence Calculation:`);
          console.log(`   ðŸ“Š Confidence Interval: [${lower}, ${upper}]`);
          console.log(`   ðŸ“ Range: ${range}`);
          console.log(`   ðŸ“Š Mean: ${mean}`);
          console.log(`   ðŸŽ¯ Calculated Confidence: ${(confidence * 100).toFixed(1)}%`);
        } else {
          confidence = 0.85; // Default confidence when no interval provided
          console.log(`ðŸŽ¯ [${requestId}] Using default confidence: ${(confidence * 100).toFixed(1)}%`);
        }
        
        console.log(`\nðŸŽ¯ [${requestId}] ML PREDICTION SUCCESS:`);
        console.log(`   ðŸŒ¾ Yield per hectare: ${yieldKgPerHa} kg/ha`);
        console.log(`   ðŸ“¦ Total predicted yield: ${predictedYield} tons`);
        console.log(`   ðŸŽ¯ Confidence: ${(confidence * 100).toFixed(1)}%`);
        
        // Store ML insights
        const mlInsights = {
          yield_per_hectare_kg: yieldKgPerHa,
          confidence_interval: mlData.confidence_interval_95,
          recommendations: mlData.recommendations || [],
          model_message: mlData.message || null
        };
        
        console.log(`ðŸ’¡ [${requestId}] ML Insights:`, JSON.stringify(mlInsights, null, 2));
        
        mlModelUsed = true;
        
      } else {
        // Handle case where ML model doesn't support the crop
        console.warn(`âš ï¸ [${requestId}] ML Model doesn't support crop: ${normalizedCrop}`);
        console.log(`ðŸ“‹ ML Message: ${mlData.message || 'No prediction available'}`);
        
        // Use fallback calculation
        throw new Error(`ML model doesn't support ${normalizedCrop}. Available crops: ${mlData.message || 'RICE, GROUNDNUT'}`);
      }
      
    } catch (mlError) {
      const mlDuration = Date.now() - mlStartTime;
      console.error(`âŒ [${requestId}] ML API call failed after ${mlDuration}ms:`, mlError.message);
      
      errorDetails = {
        error_type: mlError.code || 'UNKNOWN',
        error_message: mlError.message,
        api_url: process.env.ML_MODEL_API_URL,
        timestamp: new Date().toISOString(),
        duration_ms: mlDuration,
        request_id: requestId
      };
      
      if (mlError.response) {
        console.error(`ðŸ“¥ [${requestId}] ML API Error Response:`, {
          status: mlError.response.status,
          statusText: mlError.response.statusText,
          headers: mlError.response.headers,
          data: mlError.response.data
        });
        errorDetails.api_status = mlError.response.status;
        errorDetails.api_response = mlError.response.data;
        errorDetails.api_status_text = mlError.response.statusText;
      } else if (mlError.request) {
        console.error(`ðŸ“¡ [${requestId}] ML API Request Error (no response):`, mlError.request);
        errorDetails.request_details = 'No response received from ML API';
      }
      
      console.warn(`âš ï¸ [${requestId}] Using fallback prediction calculation...`);
      
      console.warn(`âš ï¸ Using fallback prediction calculation...`);
      console.log(`
ðŸ”„ FALLBACK CALCULATION STARTED`);
      // Enhanced fallback calculation using normalized crop names
      const cropYieldData = {
        'RICE': { base: 3.8, weather_factor: 0.1, soil_factor: 0.05 },
        'WHEAT': { base: 3.2, weather_factor: 0.12, soil_factor: 0.08 },
        'MAIZE': { base: 4.5, weather_factor: 0.15, soil_factor: 0.1 },
        'SUGARCANE': { base: 75.0, weather_factor: 0.2, soil_factor: 0.15 },
        'GROUNDNUT': { base: 1.8, weather_factor: 0.08, soil_factor: 0.06 }
      };
      const cropData = cropYieldData[normalizedCrop] || { base: 3.0, weather_factor: 0.1, soil_factor: 0.05 };
      console.log(`ðŸ“Š Fallback crop data for ${normalizedCrop}:`);
      console.log(`   ðŸŒ¾ Base yield: ${cropData.base} tons/ha`);
      console.log(`   ðŸŒ¤ï¸ Weather factor: ${cropData.weather_factor}`);
      console.log(`   ðŸŒ± Soil factor: ${cropData.soil_factor}`);
      // Calculate yield with weather and soil adjustments
      let yieldPerHa = cropData.base;
      console.log(`ðŸ§® Starting with base yield: ${yieldPerHa} tons/ha`);
      // Weather adjustment based on optimal ranges
      if (finalWeatherData?.temperature) {
        const optimalTemp = normalizedCrop === 'RICE' ? 25 : normalizedCrop === 'WHEAT' ? 22 : 28;
        const tempDiff = Math.abs(finalWeatherData.temperature - optimalTemp);
        const tempFactor = Math.max(0.7, 1 - (tempDiff * 0.02)); // Reduce yield for temperature deviation
        yieldPerHa *= tempFactor;
        console.log(`ðŸŒ¡ï¸ Temperature adjustment:`);
        console.log(`   ðŸŽ¯ Optimal temperature for ${normalizedCrop}: ${optimalTemp}Â°C`);
        console.log(`   ðŸŒ¡ï¸ Actual temperature: ${finalWeatherData.temperature}Â°C`);
        console.log(`   ðŸ“ Temperature difference: ${tempDiff}Â°C`);
        console.log(`   ðŸ“Š Temperature factor: ${tempFactor.toFixed(3)}`);
        console.log(`   ðŸŒ¾ Yield after temp adjustment: ${yieldPerHa.toFixed(2)} tons/ha`);
      }
      // Rainfall adjustment based on crop requirements
      if (finalWeatherData?.rainfall) {
        const optimalRain = normalizedCrop === 'RICE' ? 120 : normalizedCrop === 'WHEAT' ? 40 : 80;
        const rainDiff = Math.abs(finalWeatherData.rainfall - optimalRain);
        const rainFactor = Math.max(0.6, 1 - (rainDiff * 0.003)); // Reduce yield for rainfall deviation
        yieldPerHa *= rainFactor;
        console.log(`ðŸŒ§ï¸ Rainfall adjustment:`);
        console.log(`   ðŸŽ¯ Optimal rainfall for ${normalizedCrop}: ${optimalRain}mm`);
        console.log(`   ðŸŒ§ï¸ Actual rainfall: ${finalWeatherData.rainfall}mm`);
        console.log(`   ðŸ“ Rainfall difference: ${rainDiff}mm`);
        console.log(`   ðŸ“Š Rainfall factor: ${rainFactor.toFixed(3)}`);
        console.log(`   ðŸŒ¾ Yield after rain adjustment: ${yieldPerHa.toFixed(2)} tons/ha`);
      }
      // Soil type adjustment
      const soilFactors = {
        'Alluvial': 1.15,
        'Black': 1.1,
        'Red': 0.95,
        'Sandy': 0.85,
        'Loamy': 1.0,
        'Red-Yellow': 0.98
      };
      const soilFactor = soilFactors[normalizedSoilType] || 1.0;
      yieldPerHa *= soilFactor;
      console.log(`ðŸŒ± Soil adjustment:`);
      console.log(`   ðŸŒ± Soil type: ${normalizedSoilType}`);
      console.log(`   ðŸ“Š Soil factor: ${soilFactor}`);
      console.log(`   ðŸŒ¾ Yield after soil adjustment: ${yieldPerHa.toFixed(2)} tons/ha`);
      predictedYield = parseFloat((yieldPerHa * landArea).toFixed(2));
      confidence = 0.65; // Lower confidence for fallback
      mlModelUsed = false;
      console.log(`ðŸ”„ FALLBACK CALCULATION COMPLETE:`);
      console.log(`   ðŸ§® Final calculation: ${yieldPerHa.toFixed(2)} tons/ha Ã— ${landArea}ha = ${predictedYield} tons`);
      console.log(`   ðŸŽ¯ Confidence: ${(confidence * 100).toFixed(1)}% (fallback)`);
    }

    // Save comprehensive prediction to database
    console.log(`ðŸ’¾ SAVING PREDICTION TO DATABASE...`);
    const prediction = new Prediction({
      userId,
      cropType,
      soilType: normalizedSoilType,
      soilData: finalSoilData, // Store complete soil data
      landArea,
      location: {
        state: location.state,
        district: location.district,
        coordinates
      },
      plantingDate,
      weather: finalWeatherData,
      externalData: {
        weatherData: fetchData ? finalWeatherData : null,
        soilData: fetchData ? finalSoilData : null,
        mlInput: mlInput, // Store input sent to ML API for debugging
        mlResponse: mlResponse?.data || null, // Store ML API response
        errorDetails: errorDetails, // Store any ML API errors
        validationWarnings: [] // Store any validation warnings
      },
      predictedYield: Math.round(predictedYield * 100) / 100, // Round to 2 decimal places
      confidence: Math.round(confidence * 10000) / 10000, // Round to 4 decimal places
      fetchedFromAPIs: fetchData,
      mlModelUsed: mlModelUsed
    });

    const savedPrediction = await prediction.save();
    console.log(`âœ… Prediction saved successfully with ID: ${savedPrediction._id}`);

    // Prepare comprehensive response for frontend
    const responseData = {
      // Basic prediction info
      predictionId: savedPrediction._id,
      success: true,
      // Input data summary
      input: {
        cropType,
        landArea,
        location: {
          state: location.state,
          district: location.district,
          coordinates
        },
        plantingDate,
        soilType: normalizedSoilType,
        soilData: finalSoilData, // Include complete soil analysis
        weather: finalWeatherData,
        fetchedFromAPIs: fetchData
      },
      // Prediction results
      prediction: {
        yield_tons: Math.round(predictedYield * 100) / 100,
        yield_per_hectare: Math.round((predictedYield / landArea) * 100) / 100,
        confidence_score: Math.round(confidence * 100),
        confidence_level: confidence > 0.8 ? 'High' : confidence > 0.6 ? 'Medium' : 'Low'
      },
      // Technical details
      technical: {
        ml_model_used: mlModelUsed,
        data_source: fetchData ? 'External APIs + Local Soil Database' : 'User Input Only',
        processing_timestamp: new Date().toISOString(),
        model_version: mlResponse?.data?.model_version || 'fallback_v1.0'
      },
      // Additional insights (if available from ML model)
      insights: mlResponse?.data?.recommendations || [
        `Expected yield: ${Math.round(predictedYield * 100) / 100} tons`,
        `Yield per hectare: ${Math.round((predictedYield / landArea) * 100) / 100} tons/ha`,
        fetchData ? 'Weather and soil data considered' : 'Based on user-provided data'
      ],
      // Timestamps
      createdAt: savedPrediction.createdAt,
      updatedAt: savedPrediction.updatedAt
    };

    console.log('ðŸ“¤ Sending response to frontend...');
    console.log('ðŸŽ‰ Prediction completed successfully!');

    res.status(201).json(responseData);
      
      const cropData = cropYieldData[normalizedCrop] || { base: 3.0, weather_factor: 0.1, soil_factor: 0.05 };
      
      // Calculate yield with weather and soil adjustments
      let yieldPerHa = cropData.base;
      
      // Weather adjustment based on optimal ranges
      if (finalWeatherData?.temperature) {
        const optimalTemp = normalizedCrop === 'RICE' ? 25 : normalizedCrop === 'WHEAT' ? 22 : 28;
        const tempDiff = Math.abs(finalWeatherData.temperature - optimalTemp);
        const tempFactor = Math.max(0.7, 1 - (tempDiff * 0.02)); // Reduce yield for temperature deviation
        yieldPerHa *= tempFactor;
      }
      
      // Rainfall adjustment based on crop requirements
      if (finalWeatherData?.rainfall) {
        const optimalRain = normalizedCrop === 'RICE' ? 120 : normalizedCrop === 'WHEAT' ? 40 : 80;
        const rainDiff = Math.abs(finalWeatherData.rainfall - optimalRain);
        const rainFactor = Math.max(0.6, 1 - (rainDiff * 0.003)); // Reduce yield for rainfall deviation
        yieldPerHa *= rainFactor;
      }
      
      // Soil type adjustment
      const soilFactors = {
        'Alluvial': 1.15,
        'Black': 1.1,
        'Red': 0.95,
        'Sandy': 0.85,
        'Loamy': 1.0,
        'Red-Yellow': 0.98
      };
      const soilFactor = soilFactors[normalizedSoilType] || 1.0;
      yieldPerHa *= soilFactor;
    }

    // Save comprehensive prediction to database
    console.log(`\nðŸ’¾ [${requestId}] SAVING PREDICTION TO DATABASE...`);
    
    const dbStartTime = Date.now();
    
    const prediction = new Prediction({
      userId,
      cropType,
      soilType: normalizedSoilType,
      soilData: finalSoilData, // Store complete soil data
      landArea,
      location: {
        state: location.state,
        district: location.district,
        coordinates
      },
      plantingDate,
      weather: finalWeatherData,
      externalData: {
        weatherData: fetchData ? finalWeatherData : null,
        soilData: fetchData ? finalSoilData : null,
        mlInput: mlInput, // Store input sent to ML API for debugging
        mlResponse: mlResponse?.data || null, // Store ML API response
        errorDetails: errorDetails, // Store any ML API errors
        validationWarnings: [] // Store any validation warnings
      },
      predictedYield: Math.round(predictedYield * 100) / 100, // Round to 2 decimal places
      confidence: Math.round(confidence * 10000) / 10000, // Round to 4 decimal places
      fetchedFromAPIs: fetchData,
      mlModelUsed: mlModelUsed
    });

    const savedPrediction = await prediction.save();
    const dbDuration = Date.now() - dbStartTime;
    
    console.log(`âœ… [${requestId}] Prediction saved successfully in ${dbDuration}ms`);
    console.log(`ðŸ“Š Database record ID: ${savedPrediction._id}`);
    console.log(`ðŸ“… Created at: ${savedPrediction.createdAt}`);

    // Prepare comprehensive response for frontend
    const responseData = {
      // Basic prediction info
      predictionId: savedPrediction._id,
      success: true,
      
      // Input data summary
      input: {
        cropType,
        landArea,
        location: {
          state: location.state,
          district: location.district,
          coordinates
        },
        plantingDate,
        soilType: normalizedSoilType,
        soilData: finalSoilData, // Include complete soil analysis
        weather: finalWeatherData,
        fetchedFromAPIs: fetchData
      },
      
      // Prediction results
      prediction: {
        yield_tons: Math.round(predictedYield * 100) / 100,
        yield_per_hectare: Math.round((predictedYield / landArea) * 100) / 100,
        confidence_score: Math.round(confidence * 100),
        confidence_level: confidence > 0.8 ? 'High' : confidence > 0.6 ? 'Medium' : 'Low'
      },
      
      // Technical details
      technical: {
        ml_model_used: mlModelUsed,
        data_source: fetchData ? 'External APIs + Local Soil Database' : 'User Input Only',
        processing_timestamp: new Date().toISOString(),
        model_version: mlResponse?.data?.model_version || 'fallback_v1.0',
        request_id: requestId,
        processing_time_ms: Date.now() - startTime
      },
      
      // Additional insights (if available from ML model)
      insights: mlResponse?.data?.recommendations || [
        `Expected yield: ${Math.round(predictedYield * 100) / 100} tons`,
        `Yield per hectare: ${Math.round((predictedYield / landArea) * 100) / 100} tons/ha`,
        fetchData ? 'Weather and soil data considered' : 'Based on user-provided data'
      ],
      
      // Timestamps
      createdAt: savedPrediction.createdAt,
      updatedAt: savedPrediction.updatedAt
    };

    const totalDuration = Date.now() - startTime;
    console.log(`\nðŸŽ‰ [${requestId}] PREDICTION COMPLETED SUCCESSFULLY!`);
    console.log(`â±ï¸ Total processing time: ${totalDuration}ms`);
    console.log(`ðŸ“¤ Sending response to frontend...`);
    console.log(`ðŸ“Š Response size: ${JSON.stringify(responseData).length} characters`);
    console.log(`ðŸŽ¯ Final prediction: ${predictedYield} tons (${(confidence * 100).toFixed(1)}% confidence)`);

    res.status(201).json(responseData);

  } catch (error) {
    const errorDuration = Date.now() - startTime;
    
    console.error(`\nâŒ [${requestId}] PREDICTION ERROR after ${errorDuration}ms:`);
    console.error(`ðŸ”¥ Error type: ${error.name || 'Unknown'}`);
    console.error(`ðŸ“„ Error message: ${error.message}`);
    console.error(`ðŸ“ Stack trace:`, error.stack);
    
    // Log request context for debugging
    console.error(`\nðŸ” [${requestId}] ERROR CONTEXT:`);
    console.error(`ðŸ‘¤ User ID: ${userId}`);
    console.error(`ðŸŒ¾ Crop type: ${cropType}`);
    console.error(`ðŸ“ Land area: ${landArea}ha`);
    console.error(`ðŸ“ Location: ${JSON.stringify(location)}`);
    console.error(`ðŸ”„ Fetch data: ${fetchData}`);
    
    // Return user-friendly error response
    res.status(500).json({
      success: false,
      error: 'Prediction processing failed',
      message: 'An error occurred while processing your prediction request. Please try again.',
      requestId: requestId,
      timestamp: new Date().toISOString(),
      debug: process.env.NODE_ENV === 'development' ? {
        error: error.message,
        type: error.name,
        stack: error.stack
      } : undefined
    });
  }
};

// Helper function to determine season from planting date
const getSeasonFromDate = (dateString) => {
  const date = new Date(dateString);
  const month = date.getMonth() + 1; // JavaScript months are 0-indexed
  
  if (month >= 3 && month <= 5) return 'Spring';
  if (month >= 6 && month <= 8) return 'Summer';
  if (month >= 9 && month <= 11) return 'Autumn';
  return 'Winter';
};

// @desc    Get all predictions for a user
// @route   GET /api/predictions/:userId
// @access  Private
const getUserPredictions = async (req, res) => {
  try {
    // Ensure the logged-in user is accessing their own predictions
    if (req.user._id.toString() !== req.params.userId) {
      return res.status(403).json({ message: 'User not authorized' });
    }

    const predictions = await Prediction.find({ userId: req.params.userId }).sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      count: predictions.length,
      data: predictions,
    });
  } catch (error) {
    console.error('Error fetching user predictions:', error);
    res.status(500).json({ success: false, message: 'Server Error' });
  }
};

module.exports = {
  createPrediction,
  getUserPredictions
};
